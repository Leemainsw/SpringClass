# **🐧 Spring 10강**

**캐시를 하는 이유**
* 서버도 부담이 덜하고(실제도 응답을 주지 않아도 되기 때문에) 사용자는 빠르게 응답을 받을 수 있다.
* 캐시를 안해야 하는 이유 (ex 리소스 생성 Post 메소드 보낼 때)
  
**안전한 메소드** => 조회만 하는 메소드 (get)<br>
**멱동적인 메소드** => 연속적인 호출이 부작용(서버 상태 변화)를 일으키지 않는 메소드<br>
**안전한 메소드 == 멱동적인 메소드**

Setter 메소드를 호출하는 수정 사항 (멱동적)<br>
증감 연산자(++,--)를 사용하는 수정 사항 (멱동적 X)

Delete 요청을 보내서 지우면 첫 번째 요청에서 리소스가 지워지고 이후 계속 호출해도 똑같은 상태로 (지워진 상태) 남아있음 -> 멱동적

println 메소드 => 안전함, 멱동적임

증감 연산자 => 안전하지 않고, 멱동적이지 않음

Q) 절대값(abs) 함수 =>
1. 안전한 함수인가?
2. 멱동적인 함수인가?

A) 멱동적이다. abs(-1) - 1 , abs(1) - 1

## 헤더
Content-Type : (바디에 포함된) 데이터의 MIME 타입을 지정

MIME 타입 : 이메일 첨부 파일(콘텐츠) 타입 알려주려고 만든 것

폼데이터 전송과 관련된 mime 타입<br>
application/x-www-form-urlencoded : 폼 데이터<br>
multipart/form : 폼 데이터 (input type이 file인 inpur 요소가 포함되어 있는 경우)
(form 데이터 mime 타입이 변경되면 바디의 구성 방식이 바뀜)



Content-Length : 바디 영역에 포함된 데이터의 크기 (단위는 바이트)를 지정
- 바디 영역의 내용이 압축된 상태의 데이터 크기로 지정됨

Content-Encoding : 보낼 데이터(바디)의 인코딩 방식 (압축 방식)을 설정

zip이 파일 압축하는 방식과 비슷하게 바디의 내용을 압축해서 보냄

압축하는 시간 (cpu bound 작업)이 일반적으로 통신 작업(IO bound 작업)보다 시간이 덜 걸려서 반응성이 좋아지므로 거의 대부분 내용을 압축해서 보냄. (특히 텍스트 데이터의 경우 압축률이 좋은 편)

Content-Encoding : identify => 무압축

**구글압축알고리즘**

Location : 이동(location) 작업시에 이동할 주소(url) 설정

A주소로 이동 -> 리다이렉트 응답(이동할 주소과 3xx 응답코드 전달) => B응답

Connection : 연경 방식 지정 헤더

TCP 연결을 위해서 소켓 준비가 필요함.ㅏ