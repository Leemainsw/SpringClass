# **🐧 Spring 8강**

### 커맨드 오브젝트를 쓰는 이유
==> 쓰지 않아도 된다. @RequestParam으로 정볼르 받아서 생성자를 호출하여 객체 생성 후 모델로 전달. 하지만 세련되지 못한 방법이다.

(자바 빈 객체인)객체 자체를 전달받기 <= 깔끔(내부적으로 setter를 호출함으로 setter 이름을 잘 지어야 함)

**기본생성자 + setter 로출로 내용 채운 객체를 핸들러 메소드로 전달**

HttpServletRequest : 요청 메시지 정보 추상화<br>
HttpServletResponse : 응답 메시지 정보 추상화

getParameterNames <= 메소드(query string 정보 가져오기)<br>
==> Q) @RequestParam 쓰면 되지 않냐? => 그래서 사실 HttpServletRequest를 쓸 일이 잘 없다.

Q) 왜 return 타입에 void를 설정했어도 잘 작동하는가?<br>
-> 무엇으로 응답을 해주었는가? => response객체를 동해서 직접 응답 메시지 작성(수동으로 직접 다 해줌)<br>

# HTTP 프로토콜
- 리얼월드 HTTP : Go언어로 직접 서버 구현하면서 HTTP 프로토콜 설명
- HTTP 완벽 가이드 : 난이도는 가장 높음 순수하게 HTTP 프로토콜만 설명

### 프로토콜 
* 규칙, 규약 (서로 이렇게 하기로 합의 한 것)
* 통신규약

#### HTTP
-> Hyper-Text-Transfer Protocol(하이퍼 텍스트를 전송하는 규칙)<br>
Hyper Text -> HTML

**요청메시지와 응답 메시지로 나뉨**
<br>
요청메시지를 보내는 측 : 브라우저 아니면 postman, curl 같은 프로그램
<br>
응답 메시지를 보내는 측 : 웹서버(jsp, spring, php, asp, django)


**요청, 응답 메시지가 구성되는 방식 + 의미 기타 등등 => 프로토콜 공부**

- 시작중, 헤더 영역 및 바디 영역으로 구분

시작줄 (CRLF)<br>
헤더1 (CRLF)<br>
헤더2 (CRLF)<br>
(CRLF)<br>
바디영역정보<br>
CRLP ? Carrige Return + Line Feed<br>
Line Feed => \n (escape 문자) => 0A

